import fs from 'fs'
import config from './config.json' assert { type: 'json' } // Add a config json here

// This tool can convert file *.js to .env and change *.js

// Needed:
// - config is a json generated by output of *.js
const pathOutputENV = './.env'
// - pathOutputENV is a path for output .env
const pathConvertingFile = './config.js'
// - path to file config for converting

const content = []
const propertyList = []
const propertyDuplicated = []
const propertiesDetail = []
const wanning = []

const isSnakeCase = str => /^[A-Z0-9]+(?:_[A-Z0-9]+)*$/.test(str)
const cts = str => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)
const isObj = data => [typeof data === 'object', !Array.isArray(data), data !== null].every(Boolean)

const updateEl = ({ property, value }, type) => {
  const indexDetail = propertiesDetail.findIndex(el => el.destination === property && el.value === `process.env.${value}`)
  propertiesDetail[indexDetail] = {
    ...propertiesDetail[indexDetail],
    type,
  }
  const indexDup = propertyDuplicated.findIndex(el => el.destination === property && el.value === `process.env.${value}`)
  propertyDuplicated[indexDup] = {
    ...propertyDuplicated[indexDup],
    type,
  }
}

const convert = (json, nestedName) => {
  for (const property in json) {
    let newProperty = isSnakeCase(property) ? property : cts(property)
    if (nestedName) {
      newProperty = `${nestedName}_${newProperty}`
    }
    newProperty = newProperty.toUpperCase()

    if (propertyList.includes(property)) {
      propertyDuplicated.push({ destination: property, value: `process.env.${newProperty}` })
    } else {
      propertyList.push(property)
      propertiesDetail.push({ destination: property, value: `process.env.${newProperty}` })
    }

    const value = json[property]

    if (typeof value === 'string') {
      content.push(`${newProperty}="${value}"`)
      updateEl({ property, value: newProperty }, 'string')
    } else if (typeof value === 'boolean') {
      content.push(`${newProperty}="${value}"`)
      updateEl({ property, value: newProperty }, 'boolean')
    } else if (typeof value === 'number') {
      content.push(`${newProperty}="${value}"`)
      updateEl({ property, value: newProperty }, 'number')
    } else if (value?.constructor === Array) {
      if (!value.length) {
        content.push(`${newProperty}=""`)
        updateEl({ property, value: newProperty }, 'array-none')
      } else if (typeof value[0] === 'string') {
        content.push(`${newProperty}="${value.join(',')}"`)
        updateEl({ property, value: newProperty }, 'array-string')
      } else if (typeof value[0] === 'boolean') {
        content.push(`${newProperty}="${value.join(',')}"`)
        updateEl({ property, value: newProperty }, 'array-boolean')
      } else if (typeof value[0] === 'number') {
        content.push(`${newProperty}="${value.join(',')}"`)
        updateEl({ property, value: newProperty }, 'array-number')
      } else if (isObj(value[0])) {
        for (const [index, subValue] of value.entries()) {
          convert(subValue, `${newProperty}_${index + 1}`)
        }
      } else {
        wanning.push(property)
      }
    } else if (isObj(value)) {
      convert(value, newProperty)
    } else {
      wanning.push(property)
    }
  }
}

const writeFileENV = () => {
  try {
    convert(config)
    fs.writeFileSync(pathOutputENV, content.join('\n'))
  } catch (e) {
    console.error('writeFileENV', e)
  }
}

const modifyContentFile = (fileContent, modifyData) => {
  const executeEle = []
  for (const { destination, value, type } of modifyData) {
    let regex
    let replacer
    if (type === 'boolean') {
      regex = new RegExp(`config.${destination} = (true|false);`)
      replacer = `config.${destination}(sylitasModified) = ${value} === 'true';`
    }
    if (type === 'string') {
      regex = new RegExp(`config.${destination} = .*;`)
      replacer = `config.${destination}(sylitasModified) = ${value} || '';`
    }
    if (type === 'number') {
      regex = new RegExp(`config.${destination} = .*;`)
      replacer = `config.${destination}(sylitasModified) = Number(${value} || 0);`
    }
    if (type === 'array-none' || type === 'array-string') {
      regex = new RegExp(`config.${destination} = .*;`)
      replacer = `config.${destination}(sylitasModified) = (${value} || '').split(',');`
    }
    if (type === 'array-number') {
      regex = new RegExp(`config.${destination} = .*;`)
      replacer = `config.${destination}(sylitasModified) = (${value} || '').split(',').map(el => Number(el));`
    }
    if (type === 'array-boolean') {
      regex = new RegExp(`config.${destination} = .*;`)
      replacer = `config.${destination}(sylitasModified) = (${value} || '').split(',').map(el => !!el);`
    }
    fileContent = fileContent.replace(regex, replacer)

    if (type === 'boolean') {
      regex = new RegExp(`  ${destination}: (true|false),\n`)
      replacer = `  ${destination}(sylitasModified): ${value} === 'true',\n`
    }
    if (type === 'string') {
      regex = new RegExp(`  ${destination}: .*,\n`)
      replacer = `  ${destination}(sylitasModified): ${value} || '',\n`
    }
    if (type === 'number') {
      regex = new RegExp(`  ${destination}: .*,\n`)
      replacer = `  ${destination}(sylitasModified): Number(${value} || 0),\n`
    }
    if (type === 'array-none' || type === 'array-string') {
      regex = new RegExp(`  ${destination}: .*,\n`)
      replacer = `  ${destination}(sylitasModified): (${value} || '').split(','),\n`
    }
    if (type === 'array-number') {
      regex = new RegExp(`  ${destination}: .*,\n`)
      replacer = `  ${destination}(sylitasModified): (${value} || '').split(',').map(el => Number(el)),\n`
    }
    if (type === 'array-boolean') {
      regex = new RegExp(`  ${destination}: .*,\n`)
      replacer = `  ${destination}(sylitasModified): (${value} || '').split(',').map(el => !!el),\n`
    }
    if (regex) {
      fileContent = fileContent.replace(regex, replacer)
      if (regex.test(fileContent)) executeEle.push({ destination, value, type })
    }
  }
  if (executeEle.length) {
    modifyData
    return modifyContentFile(
      fileContent,
      modifyData.reduce((pre, cur) => {
        const { destination: des, value: val } = cur
        const isHas = executeEle.find(({ destination: cld, value: clv }) => des === cld && val === clv)
        if (!isHas) pre.push(cur)
        return pre
      }, [])
    )
  } else {
    return fileContent
  }
}

const changeFileConfig = () => {
  let fileContent = fs.readFileSync(pathConvertingFile, { encoding: 'utf8' })
  fileContent = modifyContentFile(fileContent, propertiesDetail)
  // fileContent = modifyContentFile(fileContent, propertyDuplicated);
  fileContent = fileContent.replace(/\(sylitasModified\)/g, '')
  try {
    fs.writeFileSync('./config_new.js', fileContent)
  } catch (e) {
    console.error('writeFileConfig', e)
  }
}

const main = () => {
  writeFileENV()
  changeFileConfig()
  console.log('ðŸ˜Ž Sylitas | Wanning : ', wanning)
}

main()
